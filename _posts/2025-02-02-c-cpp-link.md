---
title: 链接与库
tags: c/cpp compile
---


## 概述
链接是将一系列目标文件合并为一个目标文件的过程，合并后的目标文件可以被加载到内存并执行。链接的两个主要任务是**符号解析**和**重定位**， 符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义上，而重定位确定每个符号的最终内存地址，并根据重定位条目对引用这些符号的地方进行修改。

根据链接发生的时间划分，链接可以分为静态链接和动态链接。静态链接由静态编译器(ld)在构建期完成，动态链接由动态链接器(ld-linux.so)在加载时或运行时完成。

链接器的输入是被称为**目标文件**的二进制文件，目标文件共有3种类型：可重定位目标文件、可执行目标文件和共享目标文件（动态库）。可重定位目标文件可以被静态链接器合并成一个可执行目标文件或者共享目标文件。动态库是在加载时或运行时由动态链接器加载和链接的，要么隐含地在调用程序被加载时进行，或者根据需要在程序中调用dlopen库函数时进行。


## 静态链接

静态链接的核心在于**合并与修正**。

### 1. 符号解析 (Symbol Resolution)

*   **全局符号总表**：链接器按顺序扫描 `.o` 文件和 `.a` 库。它维护一个已定义符号集合和一个未定义符号集合。
*   **符号规则**：

    *   **强符号**：函数定义、已初始化的全局变量。
    *   **弱符号**：未初始化的全局变量（`.bss` 或 `COMMON` 块）。
    *   **解析逻辑**：不允许同名强符号；强弱并存选强；多个弱符号选空间最大的。
*   **库解析次序**：注意链接命令中 `.o` 和 `.a` 的顺序。如果库在引用它的 `.o` 之前，链接会报错 `undefined reference`。

### 2. 重定位 (Relocation)

*   **段合并**：链接器将所有输入文件的 `.text` 合并为一个大的 `.text`，`.data` 合并为一个大的 `.data`。
*   **计算地址**：此时，每个节（Section）和符号（Symbol）都有了唯一的**运行时虚拟地址**。
*   **补丁操作**：遍历 `.rela.text` 和 `.rela.data`。

    *   **R\_X86\_64\_PC32**：相对地址重定位。计算公式通常为：`S + A - P`（目标地址 + 附加数 - 当前位置）。
    *   **R\_X86\_64\_32/64**：绝对地址重定位。直接填入符号的虚拟地址。


## 目标文件：ELF 格式深度解析

ELF（Executable and Linkable Format）提供两种视角：**链接视角（节 Section）和运行视角（段 Segment）**。

*   **ELF Header**：包含 Magic Number（`7f 45 4c 46`）、字长（64位）、字节序（小端）、节头表偏移量（`e_shoff`）。
*   **`.text`**：已编译程序的机器码。
*   **`.rodata`**：只读数据，如 `printf` 的格式化字符串。
*   **`.data` 与 `.bss`**：

    *   `.data` 存已初始化的全局/静态变量，占用磁盘空间。
    *   `.bss` 存未初始化或初始化为0的全局/静态变量，仅占位，不占磁盘空间（运行时置零）。
*   **`.symtab`**：符号表，存储定义和引用的符号信息（位置，类型，名字）。
*   **`.rel(a).xxxx`**：重定位条目，指导链接器如何修改其他节的内容。



## 加载时链接 (Load-time Linking)

当你在程序启动时（运行 `main` 之前）链接 `.so` 文件。

1.  **部分链接**：静态链接阶段只拷贝符号表和重定位信息，不拷贝 `.so` 的代码。
2.  **动态加载**：加载器（`ld-linux.so`）在内存中映射动态库。
3.  **符号绑定**：加载器根据动态重定位表，修改程序中的 GOT 条目，使其指向库函数的实际地址。



## 运行时链接 (Run-time Linking)

程序已经在运行，通过代码逻辑动态加载库。

*   **API**：`dlopen()` 加载库，`dlsym()` 获取符号地址，`dlclose()` 卸载。
*   **应用场景**：热更新、插件系统（如浏览器插件）、根据配置动态选择不同算法。



## 位置无关代码 (PIC) 与 动态链接

PIC 解决了“多个进程共享同一份物理内存中的库代码”的问题。

### 1. 核心思想

**把代码中变化的地址提取到数据段中。** 代码段是只读的（可共享），数据段是可写的（每个进程私有）。

### 2. GOT (Global Offset Table)

*   放在 `.data` 段中。
*   存放全局变量和外部函数的地址。
*   **间接引用**：代码不再硬编码地址，而是通过相对于寄存器（如 `%rip`）的偏移去 GOT 查表。

### 3. PLT (Procedure Linkage Table) 与 延迟绑定 (Lazy Binding)

*   **PLT** 是一段代码，每个外部函数对应一个 PLT 条目。
*   **第一次调用**：PLT 跳转到 GOT，GOT 默认指向 PLT 的下一条指令，随后进入动态链接器解析函数真实地址，并更新 GOT。
*   **后续调用**：PLT 跳转到 GOT，GOT 此时已是真实地址，直接跳转，不再进入链接器。

### 4. 为什么叫位置无关？

因为代码段（`.text`）中所有涉及地址引用的地方都变成了**相对偏移**（找GOT）。无论动态库被加载到虚拟内存的哪个位置，代码段到 GOT 端的相对位移是固定的（因为它们在同一个文件里）。这样，一份物理内存里的代码就可以映射到多个进程不同的虚拟地址空间。






