---
title: fork原理解析
tags: linux fork process
---


## 一、进程上下文（Process Context）的结构解析

在 Linux 内核中，一个进程的上下文可以被理解为该进程在**运行中的所有状态的集合**。进程上下文分为多个层面，分别对应**用户级、内核级和硬件寄存器**的状态。


### 1. 用户级上下文（User-level Context）

用户级上下文是进程在**用户态**中运行所需的数据结构，包括以下关键部分：

*   **代码段（text segment）**：进程的机器指令，常驻内存，不能被修改（除非通过 `execve`）。
*   **数据段（data segment）**：全局变量、静态变量、常量等数据。
*   **堆（heap）**：通过 `malloc()`、`free()` 动态分配的内存。
*   **用户栈（user stack）**：用于保存函数调用栈、局部变量、参数等。

#### 深浅拷贝的概念：

*   **浅拷贝（Shallow Copy）**：只复制内存地址（虚拟地址），不复制数据本身。在 `fork()` 中，这部分内容通常只在写入时才会发生真正的“深拷贝”。
*   **深拷贝（Deep Copy）**：不仅复制地址（虚拟内存映射），还会**复制数据**，也就是物理内存的镜像。例如，当某个进程写入共享内存页后，就会触发**缺页中断**，系统将进行深拷贝。

> *所以，`fork()` 创建的子进程的**用户地址空间**是**浅拷贝初始状态**，**在写入时转化为深拷贝**。*


### 2. 内核级上下文（Kernel-level Context）

内核级上下文是操作系统用来管理进程的资源和状态的数据结构，主要包括：

*   **PCB（task\_struct）**：进程控制块，包含**进程状态、优先级、父子关系、信号处理、资源使用情况**等。
*   **文件描述符表（file descriptor table）**：存储处理的文件、管道、套接字等。
*   **信号处理表（signal handlers）**：每个信号对应一个处理函数（如 `sigaction`）。
*   **页表（Page Tables）**：实现虚拟内存到物理内存的映射。
*   **内核栈（kernel stack）**：用于保存进程在内核态运行时的寄存器、函数调用栈等信息。

#### 用户级与内核级的区分：

| 层级         | 内容                | 是否为“深拷贝”      | 是否共享      |
| :--------- | :---------------- | :------------ | :-------- |
| **用户级上下文** | 代码段、数据段、堆、用户栈     | 通常“浅拷贝”，写时深拷贝 | 是（写前共享）   |
| **内核级上下文** | PCB、文件描述符表、页表、内核栈 | 深拷贝或逻辑克隆      | 一般不共享（独立） |


### 3. 寄存器上下文（Register Context）

寄存器上下文是 CPU 在某一时刻所保存的**全部寄存器状态**，包括：

*   **RIP（Instruction Pointer）**：指向当前将要执行的指令地址。
*   **RSP（Stack Pointer）**：指向当前栈顶的地址。
*   **RAX、RBX、RCX、RDX、RBP 等通用和专用寄存器**：保存临时计算结果、参数、栈信息等。

#### 寄存器上下文如何复制：

*   内核会在 `fork()` 时**快照当前进程的寄存器状态**，并**复制到子进程**的内核栈上。
*   这是一个典型的**深拷贝**：内核将父进程在执行 `fork()` 此刻的寄存器内容复制给子进程，以实现返回状态的差异化（如子进程返回 `0`，父进程返回子进程的 PID）。

> *例如，父进程执行到 `fork()` 时，`rax` 中保存的是 `fork` 的函数调用栈信息。子进程的 `rax` 会被内核**强制设置为 0**，父进程则返回子进程的 PID。*


## 二、`fork()` 到底干了什么？（基于深浅拷贝划分）

`fork()` 是**创建一个与当前进程完全相同的子进程**，其本质是**逻辑上的“差异化克隆”**，不是简单地立即复制所有内容。下面我们用深浅拷贝的概念，逐一解析 `fork()` 的行为。



### 1. PCB 的深拷贝（`task_struct`）

*   `fork()` 首先在内核中为子进程分配一个全新的 `task_struct` 结构体。
*   **深拷贝**：将父进程的 `task_struct` 的**所有成员**（如 `PID`、`state`、`signal` 处理方式、`blocked` 信号位等）**完整复制**到子进程中。后续操作都可以理解为**对于 PCB 内部的资源指针**进行**有选择性的迭代拷贝。**
*   **修改行为**：

    *   将子进程的 `PID` 设置为新的唯一值。
    *   将 `state` 设置为 **就绪态（Runnable）**。
    *   将 `real_parent` 指向父进程。
    *   清空子进程的 **pending signals**（待处理信号）。
    *   设置状态和优先级相关字段，使其成为“独立个体会”。

> *对应“深拷贝”：就像在 C 语言中，使用 `memcpy` 复制整个结构体，使其完全独立。*



### 2. 内核栈的深拷贝（`pt_regs`）

*   内核会**为子进程分配一个独立的内核栈空间**。
*   **深拷贝**：将父进程在 `fork()` 执行时的寄存器状态（`pt_regs`）**完整复制**到子进程栈中。
*   **修改行为**：

    *   将子进程的 `rax` 设置为 `0`，用于区分父子进程。
    *   父进程中 `rax` 保存的是子进程的 PID。

> *这是一个典型的**寄存器状态的深拷贝**，用于保证进程切换后能继续正确执行。*



### 3. 页表的浅拷贝与写时深拷贝（COW 机制）

这是 `fork()` 最“聪明”的地方：它不**深拷贝所有物理内存**，而是**通过“写时复制”机制**实现高效内存共享。准确的说，对于整个页表是深拷贝，对于页表项是浅拷贝。

#### 浅拷贝（Shallow Copy）阶段：

*   **复制页表（Page Tables）**：父进程和子进程拥有一样的**页表结构**，指向**相同的物理内存页**。
*   **标记为只读**：页表中的页表项（Page Table Entry）将内存页标记为**只读（read-only）**。
*   **页共享**：父子进程在 `fork()` 之后**共享物理内存页**，直到某一个进程试图写入时。

#### 写时触发深拷贝（Deep Copy）阶段：

*   当父进程或子进程尝试修改页面时，**发生缺页中断（Page Fault）**。
*   内核会为该进程（可能是父或子）**分配新的物理页面**，并**更新页表项为可读写**。
*   这一行为就是**真正的深拷贝**，**每个进程从此拥有独立的内存页**。

> *对应 C 语言：就像两个 `struct` 分别指向一个全局变量，直到某个 `struct` 试图修改该变量，才会触发深拷贝（复制一份独立的变量，并修改指针）。*



### 4. 文件描述符表的浅拷贝

`fork()` 会**克隆文件描述符表结构**，并初始化为与父进程相同的文件描述符内容，但并未对文件结构本身（`struct file*`）进行深拷贝。

#### 浅拷贝表现：

*   子进程使用\*\*拷贝结构（not data）\*\*的方式获取父进程文件描述符表。
*   子进程中的每个 `struct file*` 指针都**指向与父进程相同的文件结构**。
*   所以，如果父进程在 `fork()` 之后**移动文件指针**（如 `lseek`），子进程的对应文件指针也会被更改。

> *不同于“资源复制”，这是“指针复制”，而非“数据复制”。这正是典型的“浅拷贝”。*



### 5. 信号处理表的深拷贝

*   `fork()` 会**深拷贝信号处理表**（例如 `struct sigaction*`），确保子进程拥有**独立的信号处理方式**。
*   即使父子进程共享某些资源，它们的**信号处理行为是独立的**。

> *这类似于在 C 语言中，两个结构体持有相同的**指针**，但内容是**独立复制**。*



## 三、 `fork()` 资源拷贝的本质：从 PCB 深拷贝到指针迭代

`fork()` 的实现并非一次性的内存镜像，而是一个**分层次的递归过程**。其核心逻辑可以概括为：**先克隆“管理者”（PCB），再根据策略处理“被管理者”（资源）。**

### 1. PCB 的深拷贝

内核首先调用 `dup_task_struct`，在内存中申请一块新区域，将父进程的 `task_struct` 及其底部的 `thread_info` / `stack` 进行**字节级的内容拷贝**（类似于 `memcpy`）。

*   **深拷贝结果**：此时子进程拥有了一份与父进程完全一致的“简历”。
*   **随后修正**：立即修改 PID、进程间关系（parent/children 指针）、状态位等特异性信息。

### 2. 资源指针的迭代处理

PCB 中包含大量指向实际资源的指针（如 `mm_struct`, `files_struct`, `fs_struct`）。在 PCB 完成深拷贝后，内核会遍历这些指针，并根据参数执行不同的拷贝策略：

| **资源指针 (在 PCB 中)**                | **对应资源内容**             | **迭代拷贝策略**                      | **拷贝性质**      | **关键点**              |
| :-------------------------------- | :--------------------- | :------------------------------ | :------------ | :------------------- |
| **`void *stack`**          | **内核栈 (Kernel Stack)** | **分配新物理内存，全量复制父进程内核栈数据**        | **深拷贝**       | 支撑子进程在内核态独立运行   |
| **`struct thread_struct thread`** | **CPU 寄存器快照**          | 在新内核栈底写入 `pt_regs`，强制修改 `rax=0` | **深拷贝**       | 子进程被调度后，弹出到cpu    |
| **`struct files_struct *files`**  | **文件描述符表**             | 增加 `struct file` 引用计数，仅拷贝指针数组   | **浅拷贝**       | 父子进程共享文件偏移量 (Offset) |
| **`struct signal_struct *sig`**   | **信号处理函数**             | 复制 `sigaction` 结构体内容            | **深拷贝**       | 确保父子进程有独立的信号处理逻辑     |
| **`struct mm_struct *mm`**        | **虚拟地址空间/页表**          | 拷贝页表结构（索引），将物理页映射设为只读           | **浅拷贝 (COW)** | 真正的深拷贝推迟到“写入”时发生     |



## 四、 完整的 `fork()` 执行流程

### 第一阶段：PCB 的深拷贝和修改

1.  **分配空间**：内核为子进程申请新的 `task_struct` 空间。
2.  **全量深拷贝**：将父进程 PCB 的数据 1:1 复制到新空间。
3.  **身份重塑**：

    *   分配新 **PID**。
    *   清空子进程的**挂起信号集**（Pending Signals）。
    *   重置**时间片**等调度统计信息。

### 第二阶段：资源指针的“迭代拷贝”与内核栈深拷贝

内核通过 `copy_process` 函数对 PCB 内的指针进行迭代，并为子进程准备独立的运行环境：

*   **内核栈的物理深拷贝 (copy\_thread/alloc\_thread\_stack)**：

    *   **动作**：内核为子进程申请一块**全新的物理内存**作为其内核栈。
    *   **深拷贝内容**：将父进程当前的内核栈内容完整复制过去。
    *   **意义**：内核栈中包含了进程在内核态运行时的函数调用链。没有这一步深拷贝，子进程在切换回用户态前就会因为找不到自己的上下文而崩溃。
*   **寄存器上下文定制定制 (copy\_thread 核心步骤)**：

    *   **位置**：在刚刚深拷贝完成的**子进程内核栈**底部，存放着 `pt_regs` 结构（即父进程进内核时的寄存器快照）。
    *   **魔改**：内核直接修改子进程内核栈上的这个快照，将 `rax` 寄存器置为 `0`。
    *   **逻辑闭环**：当子进程被调度、从内核栈恢复寄存器并返回用户态时，它“以为”自己刚执行完 `fork` 且返回值为 0。
*   **页表迭代 (copy\_mm)**：

    *   **策略**：仅深拷贝页表（Page Table）的逻辑结构，但页表项指向的物理页被标记为**只读共享**。
    *   **结果**：实现“写时复制”（COW），这是针对用户空间内存的延迟深拷贝技术。
*   **文件表迭代 (copy\_files)**：

    *   **策略**：深拷贝文件描述符表（指针数组），但数组内的指针仍指向同一个 `struct file`。
    *   **结果**：父子进程**共享文件偏移量**。




### 第三阶段：唤醒与运行

1.  **挂入队列**：将子进程状态设为 `TASK_RUNNING`。
2.  **调度择机**：将其加入就绪队列，等待 CPU 调度。
3.  **首航**：子进程第一次运行时，会从 `copy_thread` 设置的寄存器状态开始执行，从而在代码上表现为“从 `fork()` 调用处返回”。


## 参考文献


深浅拷贝相关内容参考<https://blog.csdn.net/qq_37430247/article/details/110423921>




